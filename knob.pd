#N struct 1020-knob float y1 float x2 float y3 float x4 float dx float
dy float foreground float front float background float thickness;
#N canvas 0 94 1280 930 12;
#X obj 948 650 pointer;
#X msg 948 626 traverse \$1 \, bang;
#X obj 948 601 symbol pd-\$0-graphics;
#X obj 180 269 r \$0-size;
#X obj 180 244 namecanvas \$0-knob;
#X obj 180 350 s \$0-knob;
#X obj 339 244 r \$0-size;
#X msg 339 269 donecanvasdialog 1 1 2 0 0 1 1 \$1 \$1 0 0 \, dirty
0, f 20;
#X obj 339 324 s pd-\$0-graphics;
#X obj 48 50 vsl 30 25 0 1 0 0 \$0-slider-value \$0-slider empty 0
0 0 12 -262144 -262144 -191407 1100 1;
#X obj 925 526 r \$0-slider-value;
#X obj 925 551 t b b b;
#X msg 983 551 clear;
#X obj 983 576 s pd-\$0-graphics;
#X text 181 11 Arguments specified on creation., f 107;
#X obj 651 334 expr -$f1 \; 1 + $f1 \;, f 11;
#X obj 619 244 r \$0-size;
#X text 177 216 All the resizing procedures: GoP \, subpatch \, slider
\, and margin calculations., f 113;
#X obj 544 626 r \$0-xy1;
#X obj 788 626 r \$0-foreground;
#N canvas 0 94 450 300 \$0-graphics 0;
#X scalar 1020-knob -0.1 1.1 1.1 -0.1 0.4 0.06 0 0 999 5 \;;
#X coords 0 0 1 1 30 30 2 0 0;
#X restore 48 48 pd \$0-graphics;
#X text 179 379 Playing around with the slider values \, i.e. calculating
the point at which the knob dial should be \, etc., f 34;
#X obj 181 441 r \$0-slider-value;
#X obj 181 583 s \$0-dx;
#X obj 690 625 r \$0-dx;
#X obj 738 600 r \$0-dy;
#X obj 514 601 r \$0-xy0;
#X obj 496 626 f;
#X obj 619 399 s \$0-slider-value;
#X obj 651 374 s \$0-xy0;
#X obj 725 374 s \$0-xy1;
#X obj 619 309 t b f;
#X text 494 434 Actual drawing code \, it's hard to explain \, but
there's a few documents on the net and in the vanilla library (in the
subsection datastructures)., f 86;
#X msg 180 295 donecanvasdialog 1 1 2 0 0 1 1 \$1 \$1 48 48 \, dirty
0, f 20;
#X obj 836 601 r \$0-front;
#X obj 498 319 pack s f f;
#X msg 498 344 \; \$1 size \$2 \$3;
#X obj 498 244 r \$0-size;
#X obj 535 269 - 5;
#X obj 498 269 bang;
#X obj 498 294 symbol \$0-slider;
#X obj 181 138 s \$0-size;
#X obj 604 37 loadbang;
#X obj 669 37 s \$0-slider-value;
#X obj 650 139 s \$0-front;
#X obj 296 634 r \$0-slider-value;
#X obj 296 659 outlet;
#X obj 182 634 inlet;
#X obj 182 684 s \$0-slider-set;
#X obj 48 23 r \$0-slider-set;
#X obj 473 185 s \$0-foreground;
#X obj 346 62 r \$0-slider-value;
#X obj 346 87 f;
#X obj 309 87 bang;
#X obj 785 139 s \$0-background;
#X obj 885 501 r \$0-background;
#X obj 496 771 filledpolygon background background 0 0 0 1 0 1 1 0
1;
#X text 879 766 <-Remove this if the knob <-is a black/white square.
, f 26;
#X obj 496 676 append \$0-knob y1 x2 y3 x4 dx dy foreground front background
thickness, f 65;
#X obj 496 651 pack f f f f f f f f f f, f 63;
#X obj 934 476 r \$0-thickness;
#X obj 496 796 drawcurve foreground thickness 0.5 y1 x2 0.5 0.5 y3
x4 0.5 0.5 y1, f 65;
#X obj 496 731 struct \$0-knob float y1 float x2 float y3 float x4
float dx float dy float foreground float front float background float
thickness, f 65;
#X text 179 609 Inlet and outlet., f 34;
#X obj 323 164 s \$0-thickness;
#X obj 473 115 expr if(\$3 > -1 \, \$3 \, rint(min((1 - $f2) * 18 \,
9)) * 100 + rint(min($f2 * 18 \, 9)) * 10), f 24;
#X obj 650 115 expr if(\$4 \, \$4 \, 0);
#X obj 785 115 expr if(\$5 \, \$5 \, 999);
#X text 850 266 <-Uhhh... it's an approximation of the margin. <-A
linear function and some other bullcrap. <-Whenever I test it out I
pray it works., f 46;
#X obj 604 62 t b b b;
#X obj 840 244 r \$0-thickness;
#X obj 619 269 expr (rint(-1.47 + 0.17 * $f1) - $f2 + ceil($f2 / 2)
+ 1) / $f1, f 32;
#X obj 395 441 r \$0-angle;
#X obj 934 115 expr if(\$6 \, \$6 \, 45);
#X obj 934 139 s \$0-angle;
#X obj 181 466 expr -(($f1 * (360 - 2 * $f2) + (180 + $f2)) / 360 *
6.28319), f 31;
#X obj 496 821 drawpolygon front thickness 0.5 0.5 dx dy;
#X obj 181 503 expr 0.5 - 0.45 * sin($f1) \; 0.5 - 0.45 * cos($f1)
, f 31;
#X obj 395 583 s \$0-dy;
#X obj 181 543 expr round($f1 * 25) / 25, f 16;
#X text 24 506 We need to round the values. The Y value doesn't matter
\, but-> the X does \, and we--> round it using some-> arbitrary number
I picked that works the best at most sizes. If you want a more consistent
\, but broken at a value of 0 type of knob \, remove the rounds and
route straight to the send., f 21;
#X obj 395 543 expr round($f1 * 100) / 100, f 16;
#X obj 182 659 clip 0 1;
#X obj 323 139 clip 1 9;
#X obj 181 114 expr if(\$1 \, \$1 \, 30);
#X obj 323 114 expr if(\$2 \, \$2 \, 5);
#X text 184 720 Now \, there's a way to make the knob go up and down
without using a vslider. It apparently has something to do with dragging
datastructures around... But that thing I'll figure out later., f
43;
#X connect 0 0 58 10;
#X connect 1 0 0 0;
#X connect 2 0 1 0;
#X connect 3 0 33 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 10 0 11 0;
#X connect 11 0 27 0;
#X connect 11 1 2 0;
#X connect 11 2 12 0;
#X connect 12 0 13 0;
#X connect 15 0 29 0;
#X connect 15 1 30 0;
#X connect 16 0 71 0;
#X connect 18 0 59 1;
#X connect 18 0 59 2;
#X connect 19 0 59 6;
#X connect 22 0 75 0;
#X connect 24 0 59 4;
#X connect 25 0 59 5;
#X connect 26 0 27 1;
#X connect 27 0 59 0;
#X connect 27 0 59 3;
#X connect 31 0 28 0;
#X connect 31 1 15 0;
#X connect 33 0 5 0;
#X connect 34 0 59 7;
#X connect 35 0 36 0;
#X connect 37 0 38 0;
#X connect 37 0 35 1;
#X connect 37 0 39 0;
#X connect 38 0 35 2;
#X connect 39 0 40 0;
#X connect 40 0 35 0;
#X connect 42 0 69 0;
#X connect 45 0 46 0;
#X connect 47 0 82 0;
#X connect 49 0 9 0;
#X connect 51 0 52 0;
#X connect 51 0 53 0;
#X connect 52 0 65 1;
#X connect 53 0 65 0;
#X connect 55 0 59 8;
#X connect 59 0 58 0;
#X connect 60 0 59 9;
#X connect 65 0 50 0;
#X connect 66 0 44 0;
#X connect 67 0 54 0;
#X connect 69 0 43 0;
#X connect 69 1 84 0;
#X connect 69 2 67 0;
#X connect 69 2 66 0;
#X connect 69 2 53 0;
#X connect 69 2 73 0;
#X connect 69 2 85 0;
#X connect 70 0 71 1;
#X connect 71 0 31 0;
#X connect 72 0 75 1;
#X connect 73 0 74 0;
#X connect 75 0 77 0;
#X connect 77 0 79 0;
#X connect 77 1 81 0;
#X connect 79 0 23 0;
#X connect 81 0 78 0;
#X connect 82 0 48 0;
#X connect 83 0 64 0;
#X connect 84 0 41 0;
#X connect 85 0 83 0;
#X coords 0 0 1 1 30 30 2 48 48;
